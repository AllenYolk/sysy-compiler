fn walk_const_init_val(
    init: &ConstInitVal,
    full_initializer: &mut Vec<String>,
    dims: &[i32],
    backward_prod: &[usize],
    now_level: usize,
    now_idx: &mut Vec<usize>,
    scopes: &mut Scopes,
) -> Result<(), ()> {
    match init {
        ConstInitVal::Exp(exp) => {
            let target_idx = now_idx
                .iter()
                .zip(backward_prod.iter())
                .map(|(a, b)| (*a) * (*b as usize))
                .sum::<usize>();

            let j = exp.solve(scopes)?;
            full_initializer[target_idx as usize] = j.to_string();
        }
        ConstInitVal::Array(arr) => {
            for (i, sub_init) in arr.iter().enumerate() {
                now_idx[now_level as usize] = i;
                walk_const_init_val(
                    sub_init,
                    full_initializer,
                    dims,
                    backward_prod,
                    now_level + 1,
                    now_idx,
                    scopes,
                )?;
            }
        }
    }

    Ok(())
}

pub fn parse_const_array_initializer(
    init: &ConstInitVal,
    dims: &[i32],
    scopes: &mut Scopes,
) -> Result<Vec<String>, ()> {
    let n_total = dims.iter().product::<i32>();
    let mut full_initializer = vec![String::from("0"); n_total as usize];
    let mut backward_prod = vec![1usize; dims.len()];
    for i in 2..=dims.len() {
        let j = dims.len() - i;
        backward_prod[j] = backward_prod[j + 1] * (dims[j + 1] as usize);
    }

    walk_const_init_val(init, &mut full_initializer, dims, &backward_prod, 0, &mut vec![0; dims.len()], scopes)?;

    Ok(full_initializer)
}

//////////////////////////////////////////

fn walk_const_init_val(
    // information
    init: &ConstInitVal,
    full_initializer: &mut Vec<String>,
    backward_prod: &[usize],
    // states
    level: usize,
    idx: usize,
    scopes: &mut Scopes,
) -> Result<(), ()> {
    match init {
        ConstInitVal::Exp(exp) => {
            let j = exp.solve(scopes)?;
            full_initializer[idx] = j.to_string();
        }
        ConstInitVal::Array(arr) => {
            let mut current_idx = idx;
            for sub_init in arr.iter() {
                walk_const_init_val(sub_init, full_initializer, backward_prod, level + 1, current_idx, scopes)?;
                match sub_init {
                    ConstInitVal::Exp(_) => {
                        current_idx += 1;
                    },
                    ConstInitVal::Array(_) => {
                        let l = backward_prod.len();
                        for i in level..l {
                            if current_idx % backward_prod[i] == 0 {
                                current_idx += backward_prod[i];
                                break;
                            }
                        }
                    },
                }
            }
        }
    }

    Ok(())
}

pub fn parse_const_array_initializer(
    init: &ConstInitVal,
    dims: &[i32],
    scopes: &mut Scopes,
) -> Result<Vec<String>, ()> {
    let n_total = dims.iter().product::<i32>();
    let mut full_initializer = vec![String::from("0"); n_total as usize];
    let mut backward_prod = vec![1usize; dims.len()];
    for i in 2..=dims.len() {
        let j = dims.len() - i;
        backward_prod[j] = backward_prod[j + 1] * (dims[j + 1] as usize);
    }

    walk_const_init_val(init, &mut full_initializer, &backward_prod, 0, 0, scopes)?;

    Ok(full_initializer)
}